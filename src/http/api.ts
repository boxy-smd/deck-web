/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Deck API
 * Esse √© o backend do projeto **Deck**, um projeto de uma aplica√ß√£o que servir√° como reposit√≥rio de trabalhos realizados por alunos do curso de Sistemas e M√≠dias Digitais da Universidade Federal do Cear√°.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from '../../mutator';
export interface UserIdResponseDto {
  user_id: string;
}

export interface TokenResponseDto {
  token: string;
}

export interface UserResponseDto {
  id: string;
  name: string;
  username: string;
  email: string;
  semester?: number;
  about?: string;
  profileUrl?: string;
  trails: string[];
  role: string;
  status: string;
}

export interface ProfileUpdateResponseDto {
  profile: UserResponseDto;
}

export interface UserSummaryResponseDto {
  id: string;
  name: string;
  username: string;
  semester?: number;
  about?: string;
  profileUrl?: string;
  trails: string[];
  role: string;
}

export interface UsersListResponseDto {
  users: UserSummaryResponseDto[];
}

export interface MessageResponseDto {
  message: string;
}

export interface ForgotPasswordDto {
  /** Email do usu√°rio para recupera√ß√£o de senha */
  email: string;
}

export interface ResetPasswordDto {
  /** Token de recupera√ß√£o de senha recebido por email */
  token: string;
  /**
   * Nova senha do usu√°rio
   * @minLength 6
   */
  newPassword: string;
}

export interface PublishProjectResponseDto {
  project_id: string;
}

export type ProjectSummaryResponseDtoAuthor = { [key: string]: unknown };

export type ProjectSummaryResponseDtoSubject = { [key: string]: unknown };

export type ProjectSummaryResponseDtoTrailsItem = { [key: string]: unknown };

export type ProjectSummaryResponseDtoProfessorsItem = { [key: string]: unknown };

export interface ProjectSummaryResponseDto {
  id: string;
  title: string;
  description: string;
  bannerUrl?: string;
  publishedYear: number;
  semester: number;
  createdAt: string;
  author: ProjectSummaryResponseDtoAuthor;
  subject: ProjectSummaryResponseDtoSubject;
  trails: ProjectSummaryResponseDtoTrailsItem[];
  professors: ProjectSummaryResponseDtoProfessorsItem[];
}

export interface PaginationResponseDto {
  page: number;
  perPage: number;
  total: number;
  totalPages: number;
}

export interface ProjectsListResponseDto {
  posts: ProjectSummaryResponseDto[];
  pagination: PaginationResponseDto;
}

export type ProjectDetailsResponseDtoAuthor = { [key: string]: unknown };

export type ProjectDetailsResponseDtoSubject = { [key: string]: unknown };

export type ProjectDetailsResponseDtoTrailsItem = { [key: string]: unknown };

export type ProjectDetailsResponseDtoProfessorsItem = { [key: string]: unknown };

export interface ProjectDetailsResponseDto {
  id: string;
  title: string;
  description: string;
  bannerUrl?: string;
  content: string;
  publishedYear: number;
  semester: number;
  allowComments: boolean;
  createdAt: string;
  author: ProjectDetailsResponseDtoAuthor;
  subject: ProjectDetailsResponseDtoSubject;
  trails: ProjectDetailsResponseDtoTrailsItem[];
  professors: ProjectDetailsResponseDtoProfessorsItem[];
}

export interface UploadResponseDto {
  message: string;
}

export interface ProfessorResponseDto {
  id: string;
  name: string;
}

export interface ProfessorsListResponseDto {
  professors: ProfessorResponseDto[];
}

export interface SubjectResponseDto {
  id: string;
  name: string;
}

export interface SubjectsListResponseDto {
  subjects: SubjectResponseDto[];
}

export interface TrailResponseDto {
  id: string;
  name: string;
}

export interface TrailsListResponseDto {
  trails: TrailResponseDto[];
}

export type CommentResponseDtoAuthor = { [key: string]: unknown };

export interface CommentResponseDto {
  id: string;
  content: string;
  createdAt: string;
  author: CommentResponseDtoAuthor;
}

export interface CommentsListResponseDto {
  comments: CommentResponseDto[];
}

export interface CommentCreatedResponseDto {
  comment_id: string;
}

export type UsersControllerUploadProfileImageBody = {
  /** Arquivo de imagem (JPG ou PNG) */
  file?: Blob;
};

export type ProjectsControllerUploadBannerBody = {
  /** Arquivo de imagem (JPG ou PNG) */
  file?: Blob;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Registra um novo estudante na plataforma com informa√ß√µes b√°sicas e acad√™micas.
 * @summary Cadastrar novo estudante
 */
export const usersControllerRegister = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserIdResponseDto>(
      {url: `http://localhost:3333/students`, method: 'POST', signal
    },
      options);
    }
  


export const getUsersControllerRegisterMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRegister>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerRegister>>, TError,void, TContext> => {

const mutationKey = ['usersControllerRegister'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerRegister>>, void> = () => {
          

          return  usersControllerRegister(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerRegister>>>
    
    export type UsersControllerRegisterMutationError = void

    /**
 * @summary Cadastrar novo estudante
 */
export const useUsersControllerRegister = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRegister>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerRegister>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUsersControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retorna uma lista de estudantes cadastrados. Permite filtro por nome.
 * @summary Listar estudantes
 */
export const usersControllerFetchStudents = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UsersListResponseDto>(
      {url: `http://localhost:3333/students`, method: 'GET', signal
    },
      options);
    }
  



export const getUsersControllerFetchStudentsQueryKey = () => {
    return [
    `http://localhost:3333/students`
    ] as const;
    }

    
export const getUsersControllerFetchStudentsQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFetchStudentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFetchStudents>>> = ({ signal }) => usersControllerFetchStudents(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFetchStudentsQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFetchStudents>>>
export type UsersControllerFetchStudentsQueryError = unknown


export function useUsersControllerFetchStudents<TData = Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFetchStudents>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFetchStudents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFetchStudents<TData = Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFetchStudents>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFetchStudents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFetchStudents<TData = Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar estudantes
 */

export function useUsersControllerFetchStudents<TData = Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFetchStudents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFetchStudentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Realiza login do estudante e retorna um token JWT para autentica√ß√£o.
 * @summary Autenticar estudante
 */
export const usersControllerLogin = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenResponseDto>(
      {url: `http://localhost:3333/sessions`, method: 'POST', signal
    },
      options);
    }
  


export const getUsersControllerLoginMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerLogin>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerLogin>>, TError,void, TContext> => {

const mutationKey = ['usersControllerLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerLogin>>, void> = () => {
          

          return  usersControllerLogin(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerLogin>>>
    
    export type UsersControllerLoginMutationError = void

    /**
 * @summary Autenticar estudante
 */
export const useUsersControllerLogin = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerLogin>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerLogin>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUsersControllerLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retorna as informa√ß√µes p√∫blicas do perfil de um estudante atrav√©s do nome de usu√°rio.
 * @summary Buscar perfil por nome de usu√°rio
 */
export const usersControllerGetProfile = (
    username: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponseDto>(
      {url: `http://localhost:3333/profiles/${username}`, method: 'GET', signal
    },
      options);
    }
  



export const getUsersControllerGetProfileQueryKey = (username?: string,) => {
    return [
    `http://localhost:3333/profiles/${username}`
    ] as const;
    }

    
export const getUsersControllerGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = void>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerGetProfileQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetProfile>>> = ({ signal }) => usersControllerGetProfile(username, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerGetProfile>>>
export type UsersControllerGetProfileQueryError = void


export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = void>(
 username: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = void>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = void>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar perfil por nome de usu√°rio
 */

export function useUsersControllerGetProfile<TData = Awaited<ReturnType<typeof usersControllerGetProfile>>, TError = void>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerGetProfileQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Atualiza informa√ß√µes do perfil do estudante. Requer autentica√ß√£o e o usu√°rio s√≥ pode editar seu pr√≥prio perfil.
 * @summary Editar perfil do estudante
 */
export const usersControllerEditProfile = (
    studentId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<ProfileUpdateResponseDto>(
      {url: `http://localhost:3333/profiles/${studentId}`, method: 'PUT'
    },
      options);
    }
  


export const getUsersControllerEditProfileMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerEditProfile>>, TError,{studentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerEditProfile>>, TError,{studentId: string}, TContext> => {

const mutationKey = ['usersControllerEditProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerEditProfile>>, {studentId: string}> = (props) => {
          const {studentId} = props ?? {};

          return  usersControllerEditProfile(studentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerEditProfileMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerEditProfile>>>
    
    export type UsersControllerEditProfileMutationError = void

    /**
 * @summary Editar perfil do estudante
 */
export const useUsersControllerEditProfile = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerEditProfile>>, TError,{studentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerEditProfile>>,
        TError,
        {studentId: string},
        TContext
      > => {

      const mutationOptions = getUsersControllerEditProfileMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retorna informa√ß√µes detalhadas de um estudante espec√≠fico.
 * @summary Buscar detalhes do estudante
 */
export const usersControllerGetStudentDetails = (
    studentId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponseDto>(
      {url: `http://localhost:3333/students/${studentId}`, method: 'GET', signal
    },
      options);
    }
  



export const getUsersControllerGetStudentDetailsQueryKey = (studentId?: string,) => {
    return [
    `http://localhost:3333/students/${studentId}`
    ] as const;
    }

    
export const getUsersControllerGetStudentDetailsQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError = void>(studentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerGetStudentDetailsQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>> = ({ signal }) => usersControllerGetStudentDetails(studentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerGetStudentDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>>
export type UsersControllerGetStudentDetailsQueryError = void


export function useUsersControllerGetStudentDetails<TData = Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError = void>(
 studentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetStudentDetails>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetStudentDetails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetStudentDetails<TData = Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError = void>(
 studentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetStudentDetails>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetStudentDetails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetStudentDetails<TData = Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError = void>(
 studentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar detalhes do estudante
 */

export function useUsersControllerGetStudentDetails<TData = Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError = void>(
 studentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStudentDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerGetStudentDetailsQueryOptions(studentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Envia uma imagem para ser usada como foto de perfil do estudante. Formatos aceitos: JPG, PNG. Tamanho m√°ximo: 5MB.
 * @summary Fazer upload da foto de perfil
 */
export const usersControllerUploadProfileImage = (
    username: string,
    usersControllerUploadProfileImageBody: UsersControllerUploadProfileImageBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(usersControllerUploadProfileImageBody.file !== undefined) {
 formData.append(`file`, usersControllerUploadProfileImageBody.file)
 }

      return customInstance<MessageResponseDto>(
      {url: `http://localhost:3333/profile-images/${username}`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getUsersControllerUploadProfileImageMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUploadProfileImage>>, TError,{username: string;data: UsersControllerUploadProfileImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerUploadProfileImage>>, TError,{username: string;data: UsersControllerUploadProfileImageBody}, TContext> => {

const mutationKey = ['usersControllerUploadProfileImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerUploadProfileImage>>, {username: string;data: UsersControllerUploadProfileImageBody}> = (props) => {
          const {username,data} = props ?? {};

          return  usersControllerUploadProfileImage(username,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerUploadProfileImageMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerUploadProfileImage>>>
    export type UsersControllerUploadProfileImageMutationBody = UsersControllerUploadProfileImageBody
    export type UsersControllerUploadProfileImageMutationError = void

    /**
 * @summary Fazer upload da foto de perfil
 */
export const useUsersControllerUploadProfileImage = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUploadProfileImage>>, TError,{username: string;data: UsersControllerUploadProfileImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerUploadProfileImage>>,
        TError,
        {username: string;data: UsersControllerUploadProfileImageBody},
        TContext
      > => {

      const mutationOptions = getUsersControllerUploadProfileImageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Gera um novo token JWT para o usu√°rio autenticado, permitindo continuar usando a aplica√ß√£o.
 * @summary Renovar token de autentica√ß√£o
 */
export const usersControllerRefreshToken = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<TokenResponseDto>(
      {url: `http://localhost:3333/token/refresh`, method: 'PATCH'
    },
      options);
    }
  


export const getUsersControllerRefreshTokenMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRefreshToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerRefreshToken>>, TError,void, TContext> => {

const mutationKey = ['usersControllerRefreshToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerRefreshToken>>, void> = () => {
          

          return  usersControllerRefreshToken(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerRefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerRefreshToken>>>
    
    export type UsersControllerRefreshTokenMutationError = void

    /**
 * @summary Renovar token de autentica√ß√£o
 */
export const useUsersControllerRefreshToken = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRefreshToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerRefreshToken>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUsersControllerRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Envia um email com um token para recupera√ß√£o de senha caso o email esteja cadastrado.
 * @summary Solicitar recupera√ß√£o de senha
 */
export const usersControllerForgotPassword = (
    forgotPasswordDto: ForgotPasswordDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponseDto>(
      {url: `http://localhost:3333/password/forgot`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forgotPasswordDto, signal
    },
      options);
    }
  


export const getUsersControllerForgotPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext> => {

const mutationKey = ['usersControllerForgotPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerForgotPassword>>, {data: ForgotPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerForgotPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerForgotPassword>>>
    export type UsersControllerForgotPasswordMutationBody = ForgotPasswordDto
    export type UsersControllerForgotPasswordMutationError = unknown

    /**
 * @summary Solicitar recupera√ß√£o de senha
 */
export const useUsersControllerForgotPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerForgotPassword>>,
        TError,
        {data: ForgotPasswordDto},
        TContext
      > => {

      const mutationOptions = getUsersControllerForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Redefine a senha do usu√°rio utilizando o token recebido.
 * @summary Redefinir senha
 */
export const usersControllerResetPassword = (
    resetPasswordDto: ResetPasswordDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponseDto>(
      {url: `http://localhost:3333/password/reset`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordDto, signal
    },
      options);
    }
  


export const getUsersControllerResetPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext> => {

const mutationKey = ['usersControllerResetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerResetPassword>>, {data: ResetPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerResetPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerResetPassword>>>
    export type UsersControllerResetPasswordMutationBody = ResetPasswordDto
    export type UsersControllerResetPasswordMutationError = void

    /**
 * @summary Redefinir senha
 */
export const useUsersControllerResetPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerResetPassword>>,
        TError,
        {data: ResetPasswordDto},
        TContext
      > => {

      const mutationOptions = getUsersControllerResetPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Salva um projeto como rascunho. Pode ser usado para criar um novo rascunho ou atualizar um existente.
 * @summary Salvar rascunho
 */
export const projectsControllerSaveDraft = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3333/projects/drafts`, method: 'POST', signal
    },
      options);
    }
  


export const getProjectsControllerSaveDraftMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerSaveDraft>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerSaveDraft>>, TError,void, TContext> => {

const mutationKey = ['projectsControllerSaveDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerSaveDraft>>, void> = () => {
          

          return  projectsControllerSaveDraft(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerSaveDraftMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerSaveDraft>>>
    
    export type ProjectsControllerSaveDraftMutationError = unknown

    /**
 * @summary Salvar rascunho
 */
export const useProjectsControllerSaveDraft = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerSaveDraft>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerSaveDraft>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getProjectsControllerSaveDraftMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Lista todos os rascunhos do usu√°rio autenticado.
 * @summary Listar rascunhos
 */
export const projectsControllerListDrafts = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3333/projects/drafts`, method: 'GET', signal
    },
      options);
    }
  



export const getProjectsControllerListDraftsQueryKey = () => {
    return [
    `http://localhost:3333/projects/drafts`
    ] as const;
    }

    
export const getProjectsControllerListDraftsQueryOptions = <TData = Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsControllerListDraftsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsControllerListDrafts>>> = ({ signal }) => projectsControllerListDrafts(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsControllerListDraftsQueryResult = NonNullable<Awaited<ReturnType<typeof projectsControllerListDrafts>>>
export type ProjectsControllerListDraftsQueryError = unknown


export function useProjectsControllerListDrafts<TData = Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerListDrafts>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerListDrafts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerListDrafts<TData = Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerListDrafts>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerListDrafts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerListDrafts<TData = Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar rascunhos
 */

export function useProjectsControllerListDrafts<TData = Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerListDrafts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsControllerListDraftsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Publica um novo projeto na plataforma com todas as informa√ß√µes necess√°rias incluindo disciplina, trilhas e professores.
 * @summary Publicar projeto
 */
export const projectsControllerPublishProject = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PublishProjectResponseDto>(
      {url: `http://localhost:3333/projects`, method: 'POST', signal
    },
      options);
    }
  


export const getProjectsControllerPublishProjectMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerPublishProject>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerPublishProject>>, TError,void, TContext> => {

const mutationKey = ['projectsControllerPublishProject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerPublishProject>>, void> = () => {
          

          return  projectsControllerPublishProject(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerPublishProjectMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerPublishProject>>>
    
    export type ProjectsControllerPublishProjectMutationError = void

    /**
 * @summary Publicar projeto
 */
export const useProjectsControllerPublishProject = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerPublishProject>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerPublishProject>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getProjectsControllerPublishProjectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retorna uma lista paginada de projetos publicados. Suporta busca geral por query.
 * @summary Listar publica√ß√µes
 */
export const projectsControllerFetchPosts = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsListResponseDto>(
      {url: `http://localhost:3333/posts`, method: 'GET', signal
    },
      options);
    }
  



export const getProjectsControllerFetchPostsQueryKey = () => {
    return [
    `http://localhost:3333/posts`
    ] as const;
    }

    
export const getProjectsControllerFetchPostsQueryOptions = <TData = Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsControllerFetchPostsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsControllerFetchPosts>>> = ({ signal }) => projectsControllerFetchPosts(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsControllerFetchPostsQueryResult = NonNullable<Awaited<ReturnType<typeof projectsControllerFetchPosts>>>
export type ProjectsControllerFetchPostsQueryError = unknown


export function useProjectsControllerFetchPosts<TData = Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFetchPosts>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFetchPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFetchPosts<TData = Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFetchPosts>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFetchPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFetchPosts<TData = Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar publica√ß√µes
 */

export function useProjectsControllerFetchPosts<TData = Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFetchPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsControllerFetchPostsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Busca projetos com filtros avan√ßados: t√≠tulo, professor, tags, disciplina, trilhas, semestre e ano. Suporta pagina√ß√£o.
 * @summary Buscar e filtrar publica√ß√µes
 */
export const projectsControllerFilterPosts = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsListResponseDto>(
      {url: `http://localhost:3333/posts/search`, method: 'GET', signal
    },
      options);
    }
  



export const getProjectsControllerFilterPostsQueryKey = () => {
    return [
    `http://localhost:3333/posts/search`
    ] as const;
    }

    
export const getProjectsControllerFilterPostsQueryOptions = <TData = Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsControllerFilterPostsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsControllerFilterPosts>>> = ({ signal }) => projectsControllerFilterPosts(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsControllerFilterPostsQueryResult = NonNullable<Awaited<ReturnType<typeof projectsControllerFilterPosts>>>
export type ProjectsControllerFilterPostsQueryError = void


export function useProjectsControllerFilterPosts<TData = Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFilterPosts>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFilterPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFilterPosts<TData = Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFilterPosts>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFilterPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFilterPosts<TData = Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar e filtrar publica√ß√µes
 */

export function useProjectsControllerFilterPosts<TData = Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFilterPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsControllerFilterPostsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retorna informa√ß√µes completas de um projeto espec√≠fico incluindo conte√∫do, autores, disciplina e trilhas.
 * @summary Buscar detalhes do projeto
 */
export const projectsControllerGetProject = (
    projectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectDetailsResponseDto>(
      {url: `http://localhost:3333/projects/${projectId}`, method: 'GET', signal
    },
      options);
    }
  



export const getProjectsControllerGetProjectQueryKey = (projectId?: string,) => {
    return [
    `http://localhost:3333/projects/${projectId}`
    ] as const;
    }

    
export const getProjectsControllerGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof projectsControllerGetProject>>, TError = void>(projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerGetProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsControllerGetProjectQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsControllerGetProject>>> = ({ signal }) => projectsControllerGetProject(projectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsControllerGetProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsControllerGetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof projectsControllerGetProject>>>
export type ProjectsControllerGetProjectQueryError = void


export function useProjectsControllerGetProject<TData = Awaited<ReturnType<typeof projectsControllerGetProject>>, TError = void>(
 projectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerGetProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerGetProject>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerGetProject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerGetProject<TData = Awaited<ReturnType<typeof projectsControllerGetProject>>, TError = void>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerGetProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerGetProject>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerGetProject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerGetProject<TData = Awaited<ReturnType<typeof projectsControllerGetProject>>, TError = void>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerGetProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar detalhes do projeto
 */

export function useProjectsControllerGetProject<TData = Awaited<ReturnType<typeof projectsControllerGetProject>>, TError = void>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerGetProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsControllerGetProjectQueryOptions(projectId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Remove um projeto da plataforma. Apenas o autor do projeto pode exclu√≠-lo.
 * @summary Excluir projeto
 */
export const projectsControllerDeleteProject = (
    projectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3333/projects/${projectId}`, method: 'DELETE'
    },
      options);
    }
  


export const getProjectsControllerDeleteProjectMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerDeleteProject>>, TError,{projectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerDeleteProject>>, TError,{projectId: string}, TContext> => {

const mutationKey = ['projectsControllerDeleteProject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerDeleteProject>>, {projectId: string}> = (props) => {
          const {projectId} = props ?? {};

          return  projectsControllerDeleteProject(projectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerDeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerDeleteProject>>>
    
    export type ProjectsControllerDeleteProjectMutationError = void

    /**
 * @summary Excluir projeto
 */
export const useProjectsControllerDeleteProject = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerDeleteProject>>, TError,{projectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerDeleteProject>>,
        TError,
        {projectId: string},
        TContext
      > => {

      const mutationOptions = getProjectsControllerDeleteProjectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Envia uma imagem para ser usada como banner/capa do projeto. Formatos aceitos: JPG, PNG. Tamanho m√°ximo: 5MB.
 * @summary Fazer upload do banner do projeto
 */
export const projectsControllerUploadBanner = (
    projectId: string,
    projectsControllerUploadBannerBody: ProjectsControllerUploadBannerBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(projectsControllerUploadBannerBody.file !== undefined) {
 formData.append(`file`, projectsControllerUploadBannerBody.file)
 }

      return customInstance<UploadResponseDto>(
      {url: `http://localhost:3333/projects/${projectId}/banner`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getProjectsControllerUploadBannerMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerUploadBanner>>, TError,{projectId: string;data: ProjectsControllerUploadBannerBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerUploadBanner>>, TError,{projectId: string;data: ProjectsControllerUploadBannerBody}, TContext> => {

const mutationKey = ['projectsControllerUploadBanner'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerUploadBanner>>, {projectId: string;data: ProjectsControllerUploadBannerBody}> = (props) => {
          const {projectId,data} = props ?? {};

          return  projectsControllerUploadBanner(projectId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerUploadBannerMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerUploadBanner>>>
    export type ProjectsControllerUploadBannerMutationBody = ProjectsControllerUploadBannerBody
    export type ProjectsControllerUploadBannerMutationError = void

    /**
 * @summary Fazer upload do banner do projeto
 */
export const useProjectsControllerUploadBanner = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerUploadBanner>>, TError,{projectId: string;data: ProjectsControllerUploadBannerBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerUploadBanner>>,
        TError,
        {projectId: string;data: ProjectsControllerUploadBannerBody},
        TContext
      > => {

      const mutationOptions = getProjectsControllerUploadBannerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retorna lista de professores cadastrados. Permite filtro por nome.
 * @summary Listar professores
 */
export const professorsControllerFetchProfessors = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProfessorsListResponseDto>(
      {url: `http://localhost:3333/professors`, method: 'GET', signal
    },
      options);
    }
  



export const getProfessorsControllerFetchProfessorsQueryKey = () => {
    return [
    `http://localhost:3333/professors`
    ] as const;
    }

    
export const getProfessorsControllerFetchProfessorsQueryOptions = <TData = Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProfessorsControllerFetchProfessorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>> = ({ signal }) => professorsControllerFetchProfessors(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProfessorsControllerFetchProfessorsQueryResult = NonNullable<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>>
export type ProfessorsControllerFetchProfessorsQueryError = unknown


export function useProfessorsControllerFetchProfessors<TData = Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof professorsControllerFetchProfessors>>,
          TError,
          Awaited<ReturnType<typeof professorsControllerFetchProfessors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProfessorsControllerFetchProfessors<TData = Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof professorsControllerFetchProfessors>>,
          TError,
          Awaited<ReturnType<typeof professorsControllerFetchProfessors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProfessorsControllerFetchProfessors<TData = Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar professores
 */

export function useProfessorsControllerFetchProfessors<TData = Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof professorsControllerFetchProfessors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProfessorsControllerFetchProfessorsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retorna lista de disciplinas cadastradas. Permite filtro por nome.
 * @summary Listar disciplinas
 */
export const subjectsControllerFetchSubjects = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectsListResponseDto>(
      {url: `http://localhost:3333/subjects`, method: 'GET', signal
    },
      options);
    }
  



export const getSubjectsControllerFetchSubjectsQueryKey = () => {
    return [
    `http://localhost:3333/subjects`
    ] as const;
    }

    
export const getSubjectsControllerFetchSubjectsQueryOptions = <TData = Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubjectsControllerFetchSubjectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>> = ({ signal }) => subjectsControllerFetchSubjects(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubjectsControllerFetchSubjectsQueryResult = NonNullable<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>>
export type SubjectsControllerFetchSubjectsQueryError = unknown


export function useSubjectsControllerFetchSubjects<TData = Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>,
          TError,
          Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubjectsControllerFetchSubjects<TData = Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>,
          TError,
          Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubjectsControllerFetchSubjects<TData = Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar disciplinas
 */

export function useSubjectsControllerFetchSubjects<TData = Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subjectsControllerFetchSubjects>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubjectsControllerFetchSubjectsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retorna todas as trilhas de aprendizagem dispon√≠veis na plataforma.
 * @summary Listar trilhas
 */
export const trailsControllerFetchTrails = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TrailsListResponseDto>(
      {url: `http://localhost:3333/trails`, method: 'GET', signal
    },
      options);
    }
  



export const getTrailsControllerFetchTrailsQueryKey = () => {
    return [
    `http://localhost:3333/trails`
    ] as const;
    }

    
export const getTrailsControllerFetchTrailsQueryOptions = <TData = Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTrailsControllerFetchTrailsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trailsControllerFetchTrails>>> = ({ signal }) => trailsControllerFetchTrails(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TrailsControllerFetchTrailsQueryResult = NonNullable<Awaited<ReturnType<typeof trailsControllerFetchTrails>>>
export type TrailsControllerFetchTrailsQueryError = unknown


export function useTrailsControllerFetchTrails<TData = Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof trailsControllerFetchTrails>>,
          TError,
          Awaited<ReturnType<typeof trailsControllerFetchTrails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTrailsControllerFetchTrails<TData = Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof trailsControllerFetchTrails>>,
          TError,
          Awaited<ReturnType<typeof trailsControllerFetchTrails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTrailsControllerFetchTrails<TData = Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar trilhas
 */

export function useTrailsControllerFetchTrails<TData = Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trailsControllerFetchTrails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrailsControllerFetchTrailsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retorna todos os coment√°rios de um projeto espec√≠fico, ordenados do mais recente para o mais antigo.
 * @summary Listar coment√°rios do projeto
 */
export const commentsControllerListProjectComments = (
    projectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CommentsListResponseDto>(
      {url: `http://localhost:3333/projects/${projectId}/comments`, method: 'GET', signal
    },
      options);
    }
  



export const getCommentsControllerListProjectCommentsQueryKey = (projectId?: string,) => {
    return [
    `http://localhost:3333/projects/${projectId}/comments`
    ] as const;
    }

    
export const getCommentsControllerListProjectCommentsQueryOptions = <TData = Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError = void>(projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommentsControllerListProjectCommentsQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof commentsControllerListProjectComments>>> = ({ signal }) => commentsControllerListProjectComments(projectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CommentsControllerListProjectCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof commentsControllerListProjectComments>>>
export type CommentsControllerListProjectCommentsQueryError = void


export function useCommentsControllerListProjectComments<TData = Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError = void>(
 projectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof commentsControllerListProjectComments>>,
          TError,
          Awaited<ReturnType<typeof commentsControllerListProjectComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCommentsControllerListProjectComments<TData = Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError = void>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof commentsControllerListProjectComments>>,
          TError,
          Awaited<ReturnType<typeof commentsControllerListProjectComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCommentsControllerListProjectComments<TData = Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError = void>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar coment√°rios do projeto
 */

export function useCommentsControllerListProjectComments<TData = Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError = void>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsControllerListProjectComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCommentsControllerListProjectCommentsQueryOptions(projectId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Adiciona um novo coment√°rio a um projeto. Requer autentica√ß√£o e o projeto deve permitir coment√°rios.
 * @summary Comentar em projeto
 */
export const commentsControllerCommentOnProject = (
    projectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CommentCreatedResponseDto>(
      {url: `http://localhost:3333/projects/${projectId}/comments`, method: 'POST', signal
    },
      options);
    }
  


export const getCommentsControllerCommentOnProjectMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsControllerCommentOnProject>>, TError,{projectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof commentsControllerCommentOnProject>>, TError,{projectId: string}, TContext> => {

const mutationKey = ['commentsControllerCommentOnProject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentsControllerCommentOnProject>>, {projectId: string}> = (props) => {
          const {projectId} = props ?? {};

          return  commentsControllerCommentOnProject(projectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommentsControllerCommentOnProjectMutationResult = NonNullable<Awaited<ReturnType<typeof commentsControllerCommentOnProject>>>
    
    export type CommentsControllerCommentOnProjectMutationError = void

    /**
 * @summary Comentar em projeto
 */
export const useCommentsControllerCommentOnProject = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsControllerCommentOnProject>>, TError,{projectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof commentsControllerCommentOnProject>>,
        TError,
        {projectId: string},
        TContext
      > => {

      const mutationOptions = getCommentsControllerCommentOnProjectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove um coment√°rio de um projeto. Apenas o autor do coment√°rio pode exclu√≠-lo.
 * @summary Excluir coment√°rio
 */
export const commentsControllerDeleteComment = (
    projectId: string,
    commentId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3333/projects/${projectId}/comments/${commentId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCommentsControllerDeleteCommentMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsControllerDeleteComment>>, TError,{projectId: string;commentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof commentsControllerDeleteComment>>, TError,{projectId: string;commentId: string}, TContext> => {

const mutationKey = ['commentsControllerDeleteComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentsControllerDeleteComment>>, {projectId: string;commentId: string}> = (props) => {
          const {projectId,commentId} = props ?? {};

          return  commentsControllerDeleteComment(projectId,commentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommentsControllerDeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof commentsControllerDeleteComment>>>
    
    export type CommentsControllerDeleteCommentMutationError = void

    /**
 * @summary Excluir coment√°rio
 */
export const useCommentsControllerDeleteComment = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsControllerDeleteComment>>, TError,{projectId: string;commentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof commentsControllerDeleteComment>>,
        TError,
        {projectId: string;commentId: string},
        TContext
      > => {

      const mutationOptions = getCommentsControllerDeleteCommentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reporta um coment√°rio inadequado ou ofensivo para modera√ß√£o.
 * @summary Denunciar coment√°rio
 */
export const commentsControllerReportComment = (
    commentId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponseDto>(
      {url: `http://localhost:3333/comments/${commentId}/report`, method: 'POST', signal
    },
      options);
    }
  


export const getCommentsControllerReportCommentMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsControllerReportComment>>, TError,{commentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof commentsControllerReportComment>>, TError,{commentId: string}, TContext> => {

const mutationKey = ['commentsControllerReportComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentsControllerReportComment>>, {commentId: string}> = (props) => {
          const {commentId} = props ?? {};

          return  commentsControllerReportComment(commentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommentsControllerReportCommentMutationResult = NonNullable<Awaited<ReturnType<typeof commentsControllerReportComment>>>
    
    export type CommentsControllerReportCommentMutationError = void

    /**
 * @summary Denunciar coment√°rio
 */
export const useCommentsControllerReportComment = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsControllerReportComment>>, TError,{commentId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof commentsControllerReportComment>>,
        TError,
        {commentId: string},
        TContext
      > => {

      const mutationOptions = getCommentsControllerReportCommentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
